<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>masteryoda's blog</title><link href="/" rel="alternate"></link><link href="/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2013-09-03T00:00:00+08:00</updated><entry><title>OS启动步骤简述</title><link href="/OS/description_of_OS_start-up_procedure/" rel="alternate"></link><updated>2013-09-03T00:00:00+08:00</updated><author><name>masteryoda</name></author><id>tag:,2013-09-03:OS/description_of_OS_start-up_procedure/</id><summary type="html">&lt;blockquote&gt;
&lt;h3&gt;关于磁盘的一些基础知识&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;机械硬盘盘面可以分为扇区(Sectors)和柱面(Cylinders)两种单位。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁头数(Heads)表示硬盘总共有几个磁头,也就是有几面盘片, 最大为 255 (用 8 个二进制位存储);&lt;/li&gt;
&lt;li&gt;柱面数(Cylinders) 表示硬盘每一面盘片上有几条磁道,最大为 1023(用 10 个二进制位存储);&lt;/li&gt;
&lt;li&gt;扇区数(Sectors) 表示每一条磁道上有几个扇区, 最大为 63(用 6个二进制位存储).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;硬盘分区：记录每一分区的起始柱面和终止柱面&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;主引导分区（MBR）&lt;/strong&gt; 磁盘分区的信息都存储在主引导记录（Ｍaster Boot Recorder)中，MBR在一块硬盘的地零柱面上，这也是电脑开机时要利用硬盘，就必须先读取这一区域。在这个区域里记录的硬盘中的所有分区信息，以及开机的时候可以进行开机管理程序写入的地方。&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分区表（partition table）&lt;/strong&gt; 记录整块硬盘分区状态，有64byte，所以MBR最多仅提供四个partition（分区），这就是所谓Primary(P)与Extended(E)的partition最多只能为四个的原因。而Extended最多只能为一个。(Extended中分区表自建，可再分为多个逻辑分区，Linux下设备文件名从/dev/hda5开始，前四个已经被MBR保留用来分主分区P和扩展分区E了) &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逻辑区块（Block）&lt;/strong&gt;是在partition 进行filesystem 的格式化时， 所指定的『最小储存单位』，这个最小储存单位当然是架构在sector 的大小上面( 因为sector 为硬碟的最小物理储存单位啊！ )，所以啦， Block 的大小为sector 的2 的次方倍数。此时，磁头一次可以读取一个block ，如果假设我们在格式化的时候，指定Block 为4 KBytes ( 亦即由连续的八个sector 所构成一个block )。一个block最多只能容纳一个文件，而一个文件可以存储于多个block中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h3&gt;操作系统启动步骤&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BIOS:&lt;/strong&gt;  BIOS是写入到主板上的一个程序，开机的时候系统会主动执行的第一个程序，之后BIOS会去分析计算机里有哪些存储设备，依据用户的设置取取得能够开机的硬盘，并到该硬盘里取读取第一个扇区的MBR位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MBR:&lt;/strong&gt; MBR里会放置最基本的引导加载程序，其目的是加载内核文件，它会识别硬盘内的文件系统格式，因此可以读取内核文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;h4&gt;引导加载程序(Boot loader)任务：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;提供菜单：用户可以选择不同的开机选项&lt;/li&gt;
&lt;li&gt;载入内核文件：直接指向可以开机的程序区段來开始操作系统&lt;/li&gt;
&lt;li&gt;转交其他loader：将引导加载功能转交给其他loader负责&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;</summary></entry><entry><title>事务及MySQL中事务处理方式</title><link href="/database/transaction%20in%20mysql/" rel="alternate"></link><updated>2013-08-22T00:00:00+08:00</updated><author><name>masteryoda</name></author><id>tag:,2013-08-22:database/transaction in mysql/</id><summary type="html">&lt;p&gt;事务(transaction)是作为一个不可分割的逻辑单元而被执行的一组SQL语句&lt;/p&gt;
&lt;p&gt;事务的处理是通过提交(commit)和回滚(rollback)实现的.&lt;/p&gt;
&lt;h2&gt;ACID原则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Atomic原子性&lt;/strong&gt;：构成一个事务的所有语句应该是一个独立的逻辑单元，要么全部执行成功，要么一个都不执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Consistent一致性&lt;/strong&gt;：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Isolated隔离性&lt;/strong&gt;：事务不应该互相影响，即隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Durable持久性&lt;/strong&gt;：如果事务执行成功，它的影响将被永久的记录到数据库中，并不会被回滚。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MySQL中具备事务安全性的存储引擎有InnoDB和Falcon，不具备事务安全性的存储引擎有MyISAM和MEMORY&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;MySQL中事务的使用方式：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;事务开始时发出一条START TRANSACTION语句挂起自动提交模式，执行完构成本次事务的各条语句后，使用COMMIT语句结束事务并永久的计入数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用SET autocommit = 0语句手动关闭自动提交功能，COMMIT后再SET autocommit = 1手动开启 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;START&lt;/span&gt; &lt;span class="n"&gt;TRANSACTION&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;INSERT&lt;/span&gt; &lt;span class="n"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;William&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;INSERT&lt;/span&gt; &lt;span class="n"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Wallace&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;COMMIT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;START&lt;/span&gt; &lt;span class="n"&gt;TRANSACTION&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;INSERT&lt;/span&gt; &lt;span class="n"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;William&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;INSERT&lt;/span&gt; &lt;span class="n"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;William&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;//ERROR&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ROLLBACK&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;autocommit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;INSERT&lt;/span&gt; &lt;span class="n"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;William&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;INSERT&lt;/span&gt; &lt;span class="n"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Wallace&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;COMMIT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;autocommit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;部分回滚&lt;/h4&gt;
&lt;p&gt;需要在事务过程中使用SAVEPOINT语句设置一些保存点(savepoint)，之后回滚时只要在ROLLBACK后加上保存点的名字&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;START&lt;/span&gt; &lt;span class="n"&gt;TRANSACTION&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;INSERT&lt;/span&gt; &lt;span class="n"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;VALUES&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;SAVEPOINT&lt;/span&gt; &lt;span class="n"&gt;my_savepoint&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;INSERT&lt;/span&gt; &lt;span class="n"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;VALUES&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ROLLBACK&lt;/span&gt; &lt;span class="n"&gt;TO&lt;/span&gt; &lt;span class="n"&gt;SAVEPOINT&lt;/span&gt; &lt;span class="n"&gt;my_savepoint&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;INSERT&lt;/span&gt; &lt;span class="n"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;VALUES&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;COMMIT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h2&gt;事务的隔离性&lt;/h2&gt;
&lt;p&gt;MyISAM之类的存储引擎使用了数据表级的锁定机制赖保证不同的客户不能同时修改同一个数据表，但这种做法在数据量比较大的系统上会导致并发性能下降&lt;/p&gt;
&lt;p&gt;InnoDB采用数据行级的锁定机制：在一个用户修改某个数据行的同时，另一个用户可以修改和读取同一张表中的另一个数据行。问题：一个客户的事务在何时才能看到另一个客户的事务作出的修改&lt;/p&gt;
&lt;h3&gt;并发一致性问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;脏读(dirty
   read)&lt;/strong&gt;：指某个事务所作出的修改在它尚未被提交时就可以被其他事务看到。其他时候会认为数据行已经修改好了，但那个最初修改数据行的事务还有可能被回滚，这将导致数据库里的数据发送混乱&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可重复读取(nonrepeatable read)&lt;/strong&gt;：指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。比如有一个事务执行了两次同一个SELECT语句，另一个事务在这条SELECT语句的两次执行之间修改了一些数据，就会发生这种问题&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;幻影数据行(phantom row)&lt;/strong&gt;：某个事务突然看到了一个它以前没有见过的数据行。事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;MySQL中的解决方案&lt;/h3&gt;
&lt;p&gt;InnoDB提供了4种隔离级别（PS：Falcon不支持READ UNCOMMITTED隔离级别）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;READ UNCOMMITTED&lt;/strong&gt;：允许某个事务看到其他事务尚未提交的数据行改动，三个问题均未避免&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;READ COMMITTED&lt;/strong&gt;：只允许某个事务看到其他事务已经提交的数据行改动，避免了脏读&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PEPEATABLE READ&lt;/strong&gt;：如果某事务两次执行同一个SELECT语句，其结果重复，避免了3个问题&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SERIALIZABLE&lt;/strong&gt;：比PEPEATABLE对事务的隔离更彻底：某个事务查看的数据行不允许其他事务修改&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MySQL中使用SET TRANSACTION來改变隔离级别：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;GLOBAL&lt;/span&gt; &lt;span class="n"&gt;TRANSACTION&lt;/span&gt; &lt;span class="n"&gt;ISOLATION&lt;/span&gt; &lt;span class="n"&gt;LEVEL&lt;/span&gt; &lt;span class="n"&gt;level&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;SESSION&lt;/span&gt; &lt;span class="n"&gt;TRANSACTION&lt;/span&gt; &lt;span class="n"&gt;ISOLATION&lt;/span&gt; &lt;span class="n"&gt;LEVEL&lt;/span&gt; &lt;span class="n"&gt;level&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;TRANSACTION&lt;/span&gt; &lt;span class="n"&gt;TRANSACTION&lt;/span&gt; &lt;span class="n"&gt;ISOLATION&lt;/span&gt; &lt;span class="n"&gt;LEVEL&lt;/span&gt; &lt;span class="n"&gt;level&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;非事务解决方案：&lt;/h3&gt;
&lt;h5&gt;明确的锁定数据表：&lt;/h5&gt;
&lt;p&gt;把多条语句用LOCK TABLE和UNLOCK TABLE语句括起来以把他们当作一个单元來执行，可以防止其他人在锁定有关数据表时修改他们。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;LOCK&lt;/span&gt; &lt;span class="n"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;inventory&lt;/span&gt; &lt;span class="n"&gt;WRITE&lt;/span&gt;&lt;span class="err"&gt;；&lt;/span&gt;
    &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;SELECT&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;inventory&lt;/span&gt; &lt;span class="p"&gt;...;&lt;/span&gt;
    &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;UPDATE&lt;/span&gt; &lt;span class="n"&gt;inventory&lt;/span&gt; &lt;span class="n"&gt;SET&lt;/span&gt; &lt;span class="p"&gt;......;&lt;/span&gt;
    &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;UNLOCK&lt;/span&gt; &lt;span class="n"&gt;TABLES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当执行 2 的时候如果另一个用户开始执行LOCK TABLE inventory WRITE; 由于已经数据表已经锁定这条语句将被阻塞
如果只是从某个表中进行读操作，只需加上‘读操作’的锁（读操作锁允许其他客户读，不允许对它进行写操作）LOCK TABLE inventory WRITE, customer READ;&lt;/p&gt;
&lt;h5&gt;使用相对更新操作&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;UPDATE&lt;/span&gt; &lt;span class="n"&gt;inventory&lt;/span&gt; &lt;span class="n"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;quantity&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;quantity&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;shirt&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary></entry><entry><title>算是第一篇博客吧</title><link href="/misc/my-first-blog/" rel="alternate"></link><updated>2013-08-17T00:00:00+08:00</updated><author><name>masteryoda</name></author><id>tag:,2013-08-17:misc/my-first-blog/</id><summary type="html">&lt;h1&gt;算是第一篇博客吧&lt;/h1&gt;
&lt;p&gt;一直没有写博客的习惯,之前注册了CSDN的,写了几篇后就放那儿不管了.
想想我貌似从小就没有被培养出记录的习惯,从小到大日记估计就是小学写了一周吧...&lt;/p&gt;
&lt;p&gt;本来也没想着一定要写点儿啥东西的,因为我也不知道写啥...但最近突然脑子一抽筋，想要不搞个玩玩呗～&lt;/p&gt;
&lt;p&gt;一直比较喜欢用evernote,看到好的技术文章总会剪辑到evernote中,虽说的确很方便但有时自己也就不求甚解的只是去看了,是否真正的'懂了'我也不清楚.都说当能用自己话把一件事情说明白的时候,那才是真正的懂了,so 锻炼一下自己吧&lt;/p&gt;
&lt;p&gt;第二个原因是最近读书时改用电脑做笔记,但发现evernote文本格式方面还是不够好(当然别人也不是干这个的),所以决定试着在博客上记一些读书中觉得重点的知识,方便自己今后翻阅吧&lt;/p&gt;</summary></entry></feed>